<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Book on 게을러지지마</title>
    <link>https://log.readme.website/book/</link>
    <description>Recent content in Book on 게을러지지마</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>tgkim</copyright>
    <lastBuildDate>Tue, 11 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://log.readme.website/book/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>NestJS로 배우는 백엔드 프로그래밍</title>
      <link>https://log.readme.website/book-nestjs%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%B2%A1%EC%97%94%EB%93%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</link>
      <pubDate>Tue, 11 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>https://log.readme.website/book-nestjs%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%B2%A1%EC%97%94%EB%93%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</guid>
      <description>1장 NestJS의 장점 NestJS는 Node.js에 기반을 둔 웹 API 프레임워크로서 Express 또는 Fastify 프레임워크를 래핑하여 동작한다.
Express와 Fastify는 모두 Node.js를 쉽게 사용하기 위해 만들어진 프레임워크
NestJS는 기본 설치시 Express를 사용
벤치마크 결과 Fastify가 Express보다 2배 빠르지만 Express를 사용하는 이유는 Express가 널리 사용되고 있고 많은 미들웨어가 NestJS와 호환되기 때문
NestJS는 Angular의 영향을 많이 받았다. 모듈/컴포넌트 기반으로 프로그램을 작성하고 재사용성을 높인다..
제어의 역전, 의존성 주입, AOP같은 객체 지향 개념을 도입
언어는 타입스크립트를 기반으로 채택</description>
    </item>
    
    <item>
      <title>AWS Lambda로 시작하는 서비스</title>
      <link>https://log.readme.website/book-aws-lambda%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%84%9C%EB%B9%84%EC%8A%A4/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://log.readme.website/book-aws-lambda%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%84%9C%EB%B9%84%EC%8A%A4/</guid>
      <description>서버(Server) + 리스(Less)의 합성어라 간혹 &amp;lsquo;서버가 없다&amp;rsquo;라고 문자 그대로 이해할 수 있지만, 절대 그렇지 않다.
서버리스(Serverless)는 클라우드 컴퓨팅의 모델 중 하나로 개발자가 서버를 직접 관리할 필요가 없는 아키텍처를 의미한다.
하지만 서버리스는 동적으로 서버의 자원을 할당한다.
사용자가 없다면 자원을 할당하지 않고 대기하다 요청이 들어오면 그 때 자원을 할당해서 요청을 처리하고 다시 대기 상태로 들어가게 된다. 즉, 자원을 효율적으로 사용할 수 있는 것이다. 비용 또한 대기상태를 제외한 실제 사용 자원에 대해서만 청구되기 때문에 굉장히 경제적이며, 해당 서버는 클라우드 제공 기업에서 전적으로 관리하기 때문에 개발자는 스케일링, 업데이트, 백업, 보안 등 서버에 대해 일절 관리하거나 신경 쓸 필요가 없어 비즈니스 로직에 집중하여 개발을 할 수 있다.</description>
    </item>
    
  </channel>
</rss>
