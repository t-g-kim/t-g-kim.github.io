<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>NestJS로 배우는 백엔드 프로그래밍 | 게을러지지마</title>
<meta name="robots" content='index, follow'>
<meta name="description" content="책 요약">
<meta name="generator" content="hugo-index">
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<meta name="naver-site-verification" content="df8058686cca369f7a31cb97318b2dd21d8fe4ed" />
<link rel="alternate" type="application/rss+xml" href="https://log.readme.website/index.xml" title="게을러지지마">

<meta property="og:title" content="게을러지지마" />
<meta property="og:url" content="https://log.readme.website/" />
<meta property="og:image" content="https://log.readme.website/image.jpg" />
<meta property="og:image:alt" content="No Images" />
<meta property="og:description" content="개발공부, 개발도서, 튜토리얼, 개발정리, 개발공부, 개발자, 서버개발자" />

<script async src="https://www.googletagmanager.com/gtag/js?id=G-5FRKGEC23X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-5FRKGEC23X');
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-195863746-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-195863746-2');
</script>
<link crossorigin="anonymous" href="https://log.readme.website/assets/stylesheet.css" rel="preload stylesheet" as="style">
<script crossorigin="anonymous" src="https://log.readme.website/assets/quicklink.js" rel="preload" as="script"></script>
<script>
    window.addEventListener('load', () => {
        quicklink.listen();
    });
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6690487239486575"
     crossorigin="anonymous"></script>
  </head>
  <body><header>
  <h1>
    <a href="https://log.readme.website/">
      
      <span>게을러지지마</span>
    </a>
    <span class="hl">/</span>
    <a href="https://log.readme.website/book-nestjs%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%B2%A1%EC%97%94%EB%93%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">
      <span>NestJS로 배우는 백엔드 프로그래밍</span>
    </a>
  </h1>
  <p class="desc">책 요약</p>
  <p class="bookList">
    book : 
    <a target="_blank" href="https://t-g-kim.github.io/book-aws">aws</a>
    <a target="_blank" href="https://t-g-kim.github.io/book-algorithm">algorithm</a>
  </p>
</header><div class="main">

<ul class="tagsList single">
  
  <li><a href="https://log.readme.website/book/">Book</a></li>
  
  <li><a href="https://log.readme.website/nestjs/">NestJS</a></li>
  
  <li><a href="https://log.readme.website/typescript/">Typescript</a></li>
  
</ul>

<div class="content"><p>1장
NestJS의 장점
NestJS는 Node.js에 기반을 둔 웹 API 프레임워크로서 Express 또는 Fastify 프레임워크를 래핑하여 동작한다.</p>
<p>Express와 Fastify는 모두 Node.js를 쉽게 사용하기 위해 만들어진 프레임워크</p>
<p>NestJS는 기본 설치시 Express를 사용</p>
<p>벤치마크 결과 Fastify가 Express보다 2배 빠르지만 Express를 사용하는 이유는 Express가 널리 사용되고 있고 많은 미들웨어가 NestJS와 호환되기 때문</p>
<p>NestJS는 Angular의 영향을 많이 받았다. 모듈/컴포넌트 기반으로 프로그램을 작성하고 재사용성을 높인다..</p>
<p>제어의 역전, 의존성 주입, AOP같은 객체 지향 개념을 도입</p>
<p>언어는 타입스크립트를 기반으로 채택</p>
<p>웹 프레임워크가 갖춰야 할 기능
최신 ECMA스크립트 지원</p>
<p>타입스크립트</p>
<p>CQRS</p>
<p>HTTP 헤더 보안</p>
<p>편리한 설정</p>
<p>인터셉터 : 특정 URI로 요청시 Controller로 가는 요청을 가로채는 역할을 한다.</p>
<p>다양한 미들웨어</p>
<p>스케줄링</p>
<p>로깅</p>
<p>테스팅</p>
<p>문서화</p>
<p>ORM</p>
<p>NestJS는 대부분 내장하고 있다.</p>
<p>Express가 좋을까 NestJS가 좋을까
NestJS는 백엔드 서버가 갖춰야 하는 많은 필수 기능을 프레임워크 내에 내장했고, 필요한 기능을 추가로 설치하고 적용하기 쉽다.</p>
<p>DI, IoC를 채용하여 객체지향 프로그래밍과 모듈화를 쉽게 할 수 있다. (Express를 사용하면 해당 기능들을 검토하고 npm 모듈을 찾아야하는 수고가 있다)</p>
<p>Express로 개발할 경우 속도는 확실히 빠르지만 나중엔 필수로 요구하는 라이브러리들을 계속 추가 하기 때문에 결국 NestJS에서 제공하는 기능을 모두 구현하면 성능상 크게 차이가 없다.</p>
<p>NestJS 프로젝트 생성
npm i -g @nestjs/cli</p>
<p>패키지 매니저는 무난하게 npm을 선택하는 것이 좋다. (yarn도 많으 씀)</p>
<p>*운영이 아닌 개발단계에서는 npm run start:dev 명령어를 이용하는것이 좋다.</p>
<p>(package.json에 기술된 스크립트를 보면 start:dev 키에 해당하는 값은 nest start &ndash;watch, &ndash;watch옵션은 소스코드 변경을 감지하고 코드를 저장할 때마다 서버를 다시 구동하는 옵션)</p>
<p>프레임워크와 라이브러리의 차이점</p>
<ul>
<li>프레임워크 : 개발자가 쉽게 개발을 할 수 있도록 뼈대를 제공해준다. 필수적인 코드, 알고리즘, DB connection등의 기능을 제공한다. 프레임워크는 소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게끔 상호 협력하는</li>
</ul>
<p>클래스와 인터페이스의 집합이라고 할 수 있다.</p>
<ul>
<li>라이브러리 : 개발에 필요한 것들을 미리 구현해놓은 도구, 재사용이 가능한 기능을 미리 구현해놓고 필요한 곳에서 호출하여 사용 가능하도록 만들어진 집합.</li>
</ul>
<p>→ 프레임워크와 라이브러리의 가장큰 차이점은 &ldquo;제어의 흐름&rdquo;, IoC개념이 적용되어 있다. IoC기능으로 개발자가 작성하는 코드에서 신경써야할 부분을 줄인다..</p>
<p>반면 라이브러리는 개발자가 전체적인 흐름을 만들며 라이브러리를 가져다 쓰게 된다. 개발자가 전적으로 제어흐름이 필요할 때마다 능동적으로 라이브러리를 호출하여 사용한다.</p>
<p>DI, IoC, AOP(제가 주로 스프링 개발을 했었기 때문에 스프링공부할때 나왔던 개념입니다. 스프링 기준으로 설명드립니다..)
IoC(Inversion of Control)</p>
<ul>
<li>
<p>제어의 역전</p>
</li>
<li>
<p>spring에서는 Container 개념이 있는데 Container는 객체를 담는 용기</p>
</li>
<li>
<p>bean의 생성부터 소멸까지 생명주기를 관리</p>
</li>
<li>
<p>bean은 객체 라고 보면 됨</p>
</li>
<li>
<p>쉽게말해 spring container가 필요에 따라 개발자 대신 bean을 관리해주는 행위, 제어권이 역전되었다.</p>
</li>
<li>
<p>프레임워크의 라이프사이클을 개발자 대신 관리 해준다. (생성, 초기화, 소멸.. 모든 권한을 가지고 생명주기 관리)</p>
</li>
</ul>
<p>AOP(Aspect Oriented Programming)</p>
<ul>
<li>
<p>관점지향 프로그래밍</p>
</li>
<li>
<p>여러 메서드에서 공통적으로 해야하는 일의 코드가 중복이 된다면 따로 모아서 관리를 하며 재활용 하는 것을 의미</p>
</li>
<li>
<p>코드 밖에서 개발을 해두고 프록시 개념으로 메서드가 실행되기 전, 실행된 직후, 실행 시점에 따라 기능을 적용 시키는 것.</p>
</li>
</ul>
<p>Spring AOP, Aspect 개념 특징, AOP 용어 정리</p>
<p>DI(Dependency Injection)</p>
<ul>
<li>
<p>의존성주입</p>
</li>
<li>
<p>Spring Framework 기준으로, 객체 사이에 필요한 의존 관계에 대해서 스프링 컨테이너가 자동으로 연결해 주는 것</p>
</li>
<li>
<p>코드가 간결해지고,  모듈 간의 결합도가 낮아지고 유연성이 높아진다.</p>
</li>
<li>
<p>느슨한 결합인 클래스들간의 강한 결합을 피하기 위한것</p>
</li>
<li>
<p>느슨한 결합 : 어떤 클래스가 인터페이스 같이 일반화된 구성 요소에 의존하고 있는 경우</p>
</li>
<li>
<p>애플리케이션 코드 내부에서 직접적으로 new 키워드를 사용할 경우, SOLID의 DIP인 의존 관계 역전 원칙에 위반된다. 왜냐하면 new로써 생성한 구체화된 클래스에 의존하고 있는 형식이 되기 떄문이다. 따라서  좋은 객체지향 설계가 아니라서 이것을 피하기 위해 DI가 적용되었다라고 생각해도되겠다.</p>
</li>
<li>
<p>경험상 테스트 코드 작성시 유리했다(클래스 재사용, 클래스별로 독립적으로 테스트 가능)</p>
</li>
<li>
<p>생성자 주입, setter 주입, field주입 방식이 있다.</p>
</li>
</ul>
<p>비동기, 동기, 논블로킹, 블로킹의 차이
블로킹 : 작업이 완료 될때까지 모든일을 중단하고 대기해야하는 방식</p>
<ul>
<li>
<p>A함수 내에서 B함수를 호출했다고 치자, B함수로 제어권이 넘어가게되며, A함수는 B의 작업이 끝날때까지 기다렸다가 종료되면 자신이 멈췄던 부분부터 작업을 이어나간다.</p>
</li>
<li>
<p>A함수에서 제어권을 B함수로 넘기고 다시 A함수로 제어권을 가지고 온다.</p>
</li>
</ul>
<p>논블로킹 : 작업이 중단되지 않는다. 다른작업이 완료가 될떄까지 기다리지 않고 다른작업을 수행</p>
<ul>
<li>
<p>A라는 함수가 실행중에 B함수를 호출했다고 치자, A함수는 제어권을 B함수에 넘기지 않고 그대로 자신이 가지고 있으며, B함수의 완료여부와 상관없이 작업을 계속한다.</p>
</li>
<li>
<p>호출한 함수A가 제어권을 계속 가진다.</p>
</li>
</ul>
<p>동기</p>
<ul>
<li>
<p>현재 작업의 응답이 끝남과 동시에 다음 작업이 요청된다.</p>
</li>
<li>
<p>함수를 호출하는 곳에서 호출되는 함수가 결과를 반환할 때까지 기다린다.</p>
</li>
<li>
<p>작업 완료 여부를 계속 확인</p>
</li>
</ul>
<p>비동기</p>
<ul>
<li>
<p>현재 작업의 응답이 끝나지 않은 상태에서 다음 작업이 요청된다.</p>
</li>
<li>
<p>함수를 호출하는 곳에서 결과를 기다리지 않고, 다른 함수(callback)에서 결과를 처리한다.</p>
</li>
<li>
<p>작업 완료 여부를 확인하지 않는다.</p>
</li>
</ul>
<p>예시)</p>
<p>블로킹 &amp; 동기</p>
<p>Sync Blocking 조합은 다른 작업이 진행되는 동안 자신의 작업을 처리하지 않고 (Blocking), 다른 작업의 완료 여부를 바로 받아 순차적으로 처리하는 (Sync) 방식이다. 다른 작업의 결과가 자신의 작업에 영향을 주는 경우에 활용할 수 있다.</p>
<ol>
<li>
<p>이x정 연구원 : 00선임님 API 만들어주세요.</p>
</li>
<li>
<p>00선임 : 네 알겠습니다.</p>
</li>
<li>
<p>이x정 연구원 : 00선임이 다 할때까지 아무것도 안하고 기다린다.</p>
</li>
<li>
<p>00선임 : x정 연구원님 완료했습니다.</p>
</li>
<li>
<p>이x정 연구원 : 고맙습니다. H선임님 번역좀 봐주세요.</p>
</li>
<li>
<p>H선임 : 네 알겠습니다.</p>
</li>
<li>
<p>이x정 연구원 : H선임이 다 할때까지 아무것도 안하고 기다린다.</p>
</li>
<li>
<p>H선임 : x정 연구원님 완료했습니다.</p>
</li>
<li>
<p>이x정 연구원 : 고맙습니다. N선임님 DB점 봐주세요 &hellip;&hellip;.</p>
</li>
</ol>
<p>&hellip;&hellip;&hellip;</p>
<p>비동기 &amp; 논블로킹</p>
<p>Async Non Blocking 조합은 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고 (Non Blocking), 다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 (Async) 방식이다. 다른 작업의 결과가 자신의 작업에 영향을 주지 않은 경우에 활용할 수 있다.</p>
<ol>
<li>
<p>이x정 연구원 : 00선임님 API 만들어주세요.</p>
</li>
<li>
<p>이x정 연구원 : H선임님 TC 만들어주세요.</p>
</li>
<li>
<p>이x정 연구원 : N선임님 controlplus 고쳐주세요.</p>
</li>
<li>
<p>이x정 연구원 : (나는 DMS FE 수정해야지~)</p>
</li>
<li>
<p>H선임 : TC 다만들었습니다.</p>
</li>
<li>
<p>00선임 : API 만들었습니다.</p>
</li>
<li>
<p>N선임 : 고쳤어요~</p>
</li>
</ol>
<p>동기 &amp; 논블로킹</p>
<p>Sync Non-Blocking 조합은 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고 (Non Blocking), 다른 작업의 결과를 바로 처리하여 작업을 순차대로 수행 하는 (Sync) 방식이다.</p>
<ol>
<li>
<p>이x정 연구원 : H선임님 API 고쳐주세요.</p>
</li>
<li>
<p>H선임 : 네 알겠습니다.</p>
</li>
<li>
<p>이x정 연구원 : 다음 업무하려면 API가 고쳐져야 하는데&hellip;&hellip;. H선임님 다했어요?</p>
</li>
<li>
<p>H선임 : 아직이요 API 고치는 중입니다.</p>
</li>
<li>
<p>이x정 연구원 : H 선임님 다 했어요?</p>
</li>
<li>
<p>H선임 : 아직이요 API 고치는 중입니다.</p>
</li>
<li>
<p>H선임 : 이수정 연구원님 모두 고쳤습니다.</p>
</li>
<li>
<p>이x정 연구원 :  고생했어요. 00선임님 EnergySaving 고쳐주세요</p>
</li>
<li>
<p>00선임 : 네 알겠습니다.(energysaving 고치는중&hellip;)</p>
</li>
<li>
<p>이x정 연구원 : 다음업무를 하려면 energysaving이 고쳐져야하는데&hellip;. 00선임님 다했어요??</p>
</li>
</ol>
<p>&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;</p>
<p>비동기 &amp; 블로킹</p>
<p>Async Blocking 조합은 다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다리는 (Blocking), 다른 작업의 결과를 바로 처리하지 않아 순서대로 작업을 수행하지 않는 (Async) 방식이다.</p>
<p>Async-blocking 의 경우는 실무에서 잘 마주하기 쉽지 않아 다룰일이 거의 없다. 그래서 그냥 넘어가도 크게 문제는 없다.</p>
</div>
<br><br><br>
<hr>
<script src="https://utteranc.es/client.js"
        repo="t-g-kim/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script></div><footer>
    <hr>
    <div class="footer-text">
        
        <div><a href="https://github.com/t-g-kim">github</a></div>
    </div>
</footer>
</body>
</html>
